/*
 * @Author: Scfan
 * @Date: 2018-12-13 10:57:21
 * @LastEditors: Scfan
 * @LastEditTime: 2018-12-13 14:44:16
 * @Description: 工作&amp;学习&amp;生活
 * @Email: 643566992@qq.com
 * @Company: 上海
 * @version: V1.0
 */

---
title: B_代码大全读书笔记.md
tags: MarkDown
notebook: @vscode
---

# 第00章 前言                  

 

## 第01章 软件构建中的不同开发活动

![软件构建中的不同开发活动](http://omhwhig1i.bkt.clouddn.com/18-7-23/23562729.jpg)


## 第09章 伪代码编程

伪代码编程过程有助于减少设计和编写文档所需的工作量,同时提高这两项工作的质量

## 有所获的缺陷

如果你希望程序里面一个缺陷(defect)也没有,那意味着你还没有完全理解程序的功能.
1. 你并不需要学会如何修正缺陷,你应该学会如何在一开始就避免缺陷的产生.
2. 理解你正在编写的程序
3. 明确你犯了哪种类型的错误
4. 审视自己解决问题的方法
5. 审视自己修正缺陷的方法

## 第22章 开发者测试
**测试活动的几种类别**
1. 元测试
2. 组件测试
3. 集成测试
4. 回归测试
5. 系统测试

```bash
run_01_import(){
    # 数据载入
    python tools.py --check_data $date $bankn $load_dtype
    python tools.py --load_data $date $bankn $load_dtype
    python tools.py --make_cust  $bankn $date
    python tools.py --model_entity $date_st $date_ed
}

run_02_mining_model(){
    # 模型运行 20170121
    python tools.py --mining_model 20170101 ALL
    python tools.py --mining_model 20170102 ALL
    python tools.py --mining_model 20170103 ALL
    python tools.py --mining_model 20170104 ALL
    python tools.py --mining_model 20170105 ALL

```


```python

import sys

from werkzeug.serving import run_simple
from werkzeug.wsgi import DispatcherMiddleware

from fdm.views import app


#print app.url_map
application = DispatcherMiddleware(app,{
    '/api': app
})

#print app.url_map

if __name__ == "__main__":
    run_simple('0.0.0.0', app.config['PORT'], application, use_reloader=True, use_debugger=True, threaded=True)



```


## 第24章 重构

软件演化,可以重新审视自己的代码,并竭尽所学去改进,会更有益于你的开发
重构也符合万能的80/20法则.

82定理:
1. 80%的错误存在于项目20%的类或者子程序中
2. 项目中20%的程序,占用了80%的成本
3. 修正20%的错误,需要消耗80%的资源

数据级别的重构、语句级别的重构、类级别的重构、子程序级别的重构

## 第31章中说明了代码的布局风格,以及如何布局的技巧
## 第32章中说明了好的注释技巧,包含如何注释的关键要点

## 总结说明

第01-05章内容,讲述了 代码/项目开始之前的准备工作
第06-19章内容,讲述了 代码编写过程中的注意事项和编写方法细则等
第20-26章内容,讲述了 代码测试/完善/优化
第27-29章内容,讲述了 代码集成/构建 
第30-35章内容,讲述了 其他内容,代码布局、代码注释、编程工具、个人性格等

# 第01章 欢迎进入软件架构      

## 软件构建中存在不同的开发活动:
1. 定义问题
2. 需求分析
3. 规划构建
4. 软件架构或高层设计
5. 详细设计
6. 编码与调试
7. 单元测试
8. 集成测试
9. 集成
10. 系统测试
11. 保障维护

## 软件构建的具体任务task:
- 验证有关基础工作已经完成,构建活动可以顺利进行下去
- 确定如何测试所写代码
- 设计并编写类和子程序
- 创建并命名变量和具名常量
- 选择控制结构,组织语句块
- 对你的代码进行单元测试和集成测试,并排除其中的错误
- 评审开发团队其他成员的底层设计和代码,并让他们评审你的工作
- 润饰代码,仔细进行代码的格式化和注释.
- 将单独开发的多个软件组件集成为一体.
- 调整代码,优化速度和性能,节省资源.


## 小结:详细完整构建活动,可以根据各章节标题得出.

一些重要的非构建活动包括管理(management)、需求分析、软件构架设计、用户界面设计、系统测试,
以及维护.


## 软件构建的重要性

软件构建的重要如下:
- 构建活动是软件开发的主要组成部分
- 构建活动时间软件开发中的核心活动
- 把主要精力集中于构建活动,可以大大提高程序员的生产率
- 构建活动的产物-源代码-对


# 第02章 用隐喻来理解软件开发  

隐喻的重要性
- 重要的研发成果常常来源于类比(analogy).
- 通过将一些不太理解的东西和较为理解且时分类似的东西做比较,可以对这些不太理解的东西产生更为深刻的理解.这种使用隐喻的方法叫做建模
- 科学发展的历史不是从一系列错误的隐喻到正确的隐喻,而是从不太合适到更好的转变.


如何使用软件隐喻
- 隐喻的作用像是启示(heuristic,启发、试探法),而不是算法(algorithm)
- 算法
- 一套定义明确的指定,完成指定任务
- 可预测的、确定性的、不易变化的.
- 启发式方法
- 寻求答案的技术,答案具有偶然性


**一般的软件隐喻有以下类型:**
1. 写作代码
这种隐喻认为开发方式就像写信,如果写错了,抛弃即可.对于大些的项目明显不适用.
2. 培植系统
这种隐喻认为开发就像种庄稼,耕地、播种、施肥、浇水、收割,一点一点的做,最后丰收.其核心为“每次做一点”,但缺点为无法对整个过程进行系统的控制.
- 系统生长
这种隐喻认为开发就像牡蛎产生珍珠的过程:增量式(增量的,迭代的,自适应的和演进的).就像珍珠先有一个沙粒,然后再一点一点长成珍珠.软件开发也是,可以先搭起骨架,然后一点一点附着肌肉和皮肤,一次增加一点代码,最后形成系统.优点在于不做过多的承诺,缺点在于用它来描绘软件开发过程还是不恰当.
- 建造软件
这种隐喻认为软件开发就像建筑一样,需要计划,前期准备和执行.其实软件开发的很多术语都源于建筑,比如:软件架构,脚手架,构建等.同时你还可以把建筑的很多方面引申到软件开发上来.他们具有很多的相似性.
- 智力工具箱
这种隐喻是指人们在多年的开发过程中积累了大量的技术、技巧和诀窍.在开发过程中学的越多,脑中工具箱可用的工具就越多,以后合适的时候就可以拿出来用.

小结


## 关键点


# 第03章 前期准备              
# 第04章 关键点的构建决策      



选择编程语言
- 编程语言的选择从多个方面影响生产率和代码质量.
- 程序员使用三年以上的语言编写编码时,效率高 30%
- 丰富经验的编程语言的生产率比没有经验的高三倍
- 使用高级语言比使用低级语言有更好的质量和生产率
    - 生产率、可靠性、简洁性、易理解性等 高 5-15 倍
    - 高级语言的表达能力更强
- 语言的表达能力和思考能力之间关系的假说
-思考能力取决于是否知道表达该思想的词汇
编程语言影响程序员的思维


**语言描述 - 不同编程语言简介**
- Ada 通用高级编程语言
    - 基于Pascal
    - 适合实时及嵌入式系统
- 汇编语言
    - 一种低级语言
    - 每条语句对应一条机器指令
- C
    - 通用中级语言
    - 具有某些高级语言的特征
- C++
    - 面向对象的语言,基于C语言
- C#
    - 面向对象语言和编程环境
    - 提供大量工具
- Fortran第一个高级计算机语言
- Java
    - 面向对象的语言
    - java广泛用于web应用的编程
- javascript 解释执行的脚本语言
- Perl 处理字符串的语言,常用语系统管理任务、试生产处理报表、、
- PHP 开源的脚本语言,
    - 能在所有操作系统上运行,用于执行服务器的交互功能
- Python
    - 解释性的、交互性的面向对象语言,
- sql
    - sql语言时查询、更新、管理关系数据库的事实标准
- visual basic
    - 面向对象的可视化basic语言.


编程约定

任何大型程序都需要一个控制结构,用于统一编程语言的细节.
成功编程的一个关键在于避免随意变化.



技术浪潮中的位置
    - 你如何面对自己的编程工作.取决于在技术浪潮中的位置.


深入一种语言去编程

"在一种语言上编程"和"深入一种语言去编程"有很大区别.
大多数编程原则都不依赖特定语言,而是依赖使用语言的方式.
如果使用的语言缺乏所希望的构建,或者存在某些问题,可以尝试去弥补,
发明自己的编码约定、标准、类库以及其他改进措施等.


选择主要的构建实践方法

构建有很多准备工作,详细偏向哪些准备工作,依靠项目特定环境而定.





要点
















# 第05章 软件构建中的设计      

对优秀的设计师,他们共有的一项特质就是对变化的预期能力.

好的程序设计所面临的最重要挑战之一就是适应变化.

目标应该是把不稳定的区域隔离出来,从而把变化所带来的影响限制在一个子程序、类或者包的内部.

下面是你应该采取的应对各种变动的措施:
- 找出看起来容易变化的项目.
    - 如果需求做得很好,那么其中就应该包含一份潜在变化的清单,以及其中每一项变化发生的可能性.
    - 在这种情况下,找出潜在的变化就非常容易了.
    - 如果需求中没有包括潜在的变化,
    - 请业务规则、对硬件的依赖性、输入和输出、被标准的语言特性、困难的设计区域和构建区域、状态变量等方面考虑变化.
- 把容易变化的项目分离出来.
    - 把第一步中找出的容易变化的组件单独划分成类,或者和其他容易同时发生变化的组件划分到同一个类中.
- 把看起来容易变化的项目隔离出来.
    - 设法设计好类之间的接口,使其对潜在的变化不敏感.
    - 设计好类的接口,把变化限制在类的内部,且不会影响类的外部.
    - 任何使用了这个将会发生变化的类的其他类都不会察觉到变化的存在.
    - 类的接口应该肩负起保护类的隐私的职责.

## 设计模式:

### 创建型模式

Singleton:模式解决实体对象个数问题,除Singleton之外,其他创建型模式解决的都是new所带来的耦合关系.

Factory mothod(工厂方法) 、abstract factory (抽象工厂)、Builder都需要一个额外的工厂类来负责实例化"易变对象".

而Prototype则是通过原型(一个特殊的工厂类)来克隆“易变对象”.

### 结构型模式


Adapter模式注重转换接口,将不吻合的接口适配对接.
Bridge模式注重分离接口与其实现,支持多维度变化.
Composite模式注重统一接口,将“一对多”的关系转化为“一对一”的关系.
Decorator模式注重稳定接口,在此前提下为对象扩展功能.
Facade模式注重简化接口,简化组件系统与外部客户程序的依赖关系.
Flyweight模式注重保留接口,在内部使用共享技术对对象存储进行优化.
Proxy模式注重假借接口,增加间接层来实现灵活控制.

### 行为型模式

Template Method模式封装算法结构,支持算法子步骤变化.
Strategy模式注重封装算法,支持算法的变化.
State模式注重封装与状态相关的变化,支持状态的变化.
Memento模式注重封装对象状态的变化,支持状态保存/恢复.
Mediator模式注重封装对象间的交互,支持对象交互的变化.
Chain Of Responsibility模式注重封装对象责任,支持责任的变化.
Command模式注重将请求封装为对象,支持请求的变化.
Iterator模式注重封装集合对象内部结构,支持集合的变化.
Interpreter模式注重封装特定领域变化,支持领域问题的频繁变化.
Observer模式注重封装对象通知,支持通信对象的变化.
Visitor模式注重封装对象操作变化,支持在运行时为类层次结构动态添加新的操作.

## 理想的设计特征


最小的复杂度(Minimal complexity):
- 设计的首要目标是让复杂度最小.
- 要避免“聪明的”设计,因为“聪明的”设计常常都是难于理解的.
- 应该做出简单且易于理解的设计.
- 如果你的设计方案不能让你在专注于程序的一部分时安心地忽视其他部分的话,这一设计就没有什么作用了.

易于维护(Ease of maintenance):
- 意味着在设计时为做维护工作的程序员着想.
- 请时刻想着维护程序员可能会就你写的代码而提出的问题.
- 把这些程序员当成你的听众,进而设计出能自解释的系统来.


松散耦合(loose coupling):
- 意味着在设计时让程序的各个组成部分之间关联最小.
- 通过应用类接口中的合理抽象、封装性及信息隐藏等原则,设计出相互关联尽可能最少的类.
- 减少关联也就减少了集成、测试与维护工作量.

可扩展性(extensibility):
- 是说你能增强系统的功能而无须破坏其底层结构.
- 你可以改动系统的某一部分而不会影响到其他部分.
- 越是可能发生的改动,越不会给系统造成什么破坏.

可重用性(reusability):
- 意味着所设计的系统的组成部分能在其他系统中重复使用.

高扇入(high fan-in):
- 是说让大量的类使用某个给定的类.
- 这意味着设计出的系统很好地利用了在较低层次上的工具类(utility classes).

低扇出(low fan-out):
- 是说让一个类里少量或适中地使用其他的类.
- 高扇出(超过约7个)说明一个类使用大量其他的类,因此可能变得过于复杂.

可移植性(portability):
- 设计出的系统应该很方便地移植到其他环境中.

精简性(cleanness):
- 设计出的系统没有多余的部分.
- 任何多余的代码也需要开发、Review和测试,
- 并且修改了其他代码后还要重新考虑这部分.

层次性(stratification):
- 意味着尽量保持系统各个分解层的层次性,
- 是你能在任意的层面上观察系统,并得到某种具有一致性的看法.

标准技术(Standard techniques):
- 要尽量用标准化的、常用的方法,让整个系统给人一种熟悉的感觉.

## 设计中启发式方法
设计中启发式方法的总结:
- 寻找现实世界的对象
- 形成一致的抽象
- 封装实现细节
- 在可能的情况下继承
- 信息隐藏
- 找出容易改变的区域
- 保存松散耦合
- 探寻通用的设计模式

## 设计策略

自上而下策略和自下而上策略的最关键的区别在于,

前者是一种分解策略,后者是一种合成策略；

前者从一般性的问题出发,把该问题分解成可控的部分.

后者从可控的部分出发,去构造一个通用的方案.

这两种方法都有各自的强项和弱项.

## 记录设计成果

把设计文档插入到代码里:
- 在代码注释中写明关键的设计决策,这种注释通常放在文件或者类的开始位置.
- 如果你同时使用类似于JavaDoc这样的文档提取工具,那么这种方法会确保设计文档对于开发这部分代码的程序员来说是立等可取的,同时也有助于程序员保持代码和设计文档之间的相当不错的同步.

用Wiki来记录设计讨论和决策:
- 把你们的设计讨论写到项目的Wiki里去(Wiki是指一组可以由项目组所有成员用网络浏览器轻松编辑的网页).
- 尽管文字录入要比交谈麻烦一些,但这样会自动地记录下你们的设计讨论和设计决策.
- 如果使用Wiki,你可以用图片来弥补文字讨论的不足,并链接支持该设计决策的网站、白皮书及其他材料.
- 如果你的开发团队在地理位置上是分布式的,那么这种技术会非常有帮助.

写总结邮件:
- 每次就设计展开讨论过后,请采取这种做法,
     - 即指派某人来写出刚才讨论的纲要——特别是那些决定下来的事项——然后发送给整个项目组.
- 在项目的公共电子邮件文件夹里保留一份备份.

使用数码相机:
- 在对设计进行文档化时有一个很常见的障碍,那就是用流行的画图工具画设计图表太麻烦.
- 不过文档化可不仅限于“用漂亮的格式、正规的符号来记录设计”和“不做任何设计文档”这两种选择.
- 把白板上画出的图表照成相片然后嵌入到传统的文档里,这样做可以带来事半功倍的效果,因为它的工作量只是用画图工具画设计图表的1%,而它的收益却能达到保存设计图表的80%.

保留设计挂图:
- 如果你把设计记录在大的挂图上,那么你只需把这些挂图保存在方便的地方即可,或者采用更好的做法,把它们张帖在项目工作区域的墙上,让大家能够很容易地随时查阅和修改.

使用CRC(类、职责、合作者)卡片:
- 另外一种技术含量较低的文档记录方案是使用索引卡片.
- 在每张卡片上,设计者写下类的名称、职责和合作者(与这个类合作的其他类).
- 一个设计团队便按照这些卡片的内容展开工作,直到他们认为已经创建出一个好的设计方案为止.
- 到那个时候,你只需把这些卡片保留下来,留待日后引用.
- 索引卡片非常便宜,不吓人,易于携带,并且有助于促进团队合作(Beck 1991).

在适当的细节层创建UML图:
- 一种流行的绘制设计图的方法是由对象管理组织(Object Management Group)定义的统一建模语言(UML)(Fowler 2004).
- UML提供了一套丰富的、形式化的表示法,可用于设计实体(entity)及其关系(relationship).
- 你可以用非正式的UML图来帮助讨论和发现设计思路.
- 从最简单的草图开始,直到你最终选定了一套设计方案,才往其中增加细节.
- 由于UML是标准化的,因此在交流设计观念时大家都能理解它,同时还能加快团队共同讨论各种设计方案的速度.

# 第06章 可以工作的类          


包含(“有一个……”的关系)
继承(“是一个……”的关系)

研究表明,人们在做其他事情时,能够记住的离散项目的个数是7+-2个.

如果一个类中包含有超过7个数据成员时,请考虑要不要把他分解成为几个更小的类.

创建类的合理原因:
- 对现实世界中的对象建模、
- 对抽象对象建模、
- 降低复杂度
- 隔离复杂度
- 隐藏实现细节
- 限制变化所影响的范围
- 隐藏全局数据
- 让参数传递更顺畅
- 创建中心控制点
- 让代码更易于重用
- 让程序族做计划
- 把相关操作放到一起
- 实现特定重构.


要点:
- 类的接口应提供一致的抽象.很多问题都是由于违背该原则而引起的.
- 类的接口应该隐藏一些信息——如某个系统接口、某项设计决策、或者一些实现细节.
- 包含往往比继承更为可取——除非你要对“是一个/is a”的关系建模.
- 继承是一种有用的工具,但它却会增加复杂度.
- 类是管理复杂度的首选工具.

# 第07章 高质量的子程序        

要点:
- 子程序代码长度最好控制在200行之内,如果超过200行,会在可读性方面遇到问题.
- 把宏表达式整个包含在括号内,比如:#define Cube(a) (a*a*a)
- 创建子程序最主要的目的是提高程序的可管理性,
    - 当然也有其他一些好的理由.其中,节省代码空间只是一个次要原因:提高可读性、可靠性和可修改性等原因都更重要一些.
- 子程序可以按照其内聚性分为很多类
    - (功能内聚、顺序内聚、通讯内聚、临时内聚过程内聚、逻辑内聚、巧合内聚),
    - 而你应该让大多数子程序具有功能上的内聚性,这是最佳的一种内聚性.
- 子程序的名字是它的质量的指示器.
    - 如果名字槽糕但是恰如其分,那就说明这个子程序设计得很差劲.准确使用对应词,下面列出一些常见的对应词组:

|词组1|词组2|词组3|
|:---:|:---:|:---:|
|add/remove     | increment/decrement |    open/close     |
|begin/end      |   insert/delete     |      show/hide    |
|create/destroy | lock/unlock         |   source/target   |
|first/last     |      min/max        |        start/stop |
|get/put        |    next/previous    |     up/down       |
|get/set        |     old/new         |                   |
- 只有在某个子程序的主要目的是返回由其名字所描述的特定结果时,才应该使用函数.
- 细心的程序员会非常谨慎地使用宏,而且只在万不得已时才用.

# 第08章 防御式编程            


> 防御式编程的主要思想是:
> 子程序应该不因传入错误数据而被破坏,哪怕是有其他子程序产生的错误数据.
> 简单点讲就是容错性.

要点:
最终产品代码中对错误的处理方式要对“垃圾进,垃圾出”复杂得多.
防御式编程技术可以让出错误更容易发现、更容易修改,并减少错误对产品代码的破坏.
断言可以帮助人尽早发现错误,尤其是在大型系统和高可靠性的系统中,以及快速变化的代码中.包含C++
、Java和Microsoft Visual Basic在内的很多语言都支持断言,比如C++中标准的aasert宏并不支持文本消息.

下面实例给出了一个使用C++宏改进的ASSERT实现:
```c
#define ASSERT(condition,message){
       if(!(condition)){
              LogError("Assertion failed:",!condition,message);
              exit(EXIT_FAILURE);
       }
}
```

关于如何处理错误输入的决策是一项关键的错误处理决策,也是一项关键的高层设计决策.

常用处理技术:
- 返回中立值、
- 换用一一个正确的数据、
- 返回与前次相同的数据、
- 换用最接近的合法值、
- 把警告信息记录到日志文件中、
- 返回一个错误码、
- 调用错误处理子程序或对象、
- 当错误发生时显示出错信息、
- 用最妥当的方式在局部处理错误、闭关程序.

异常提供了一种与代码正常流程角度不同的错误处理手段.

如果留心使用异常,它可以成为程序员们知识工具箱中一项有益补充,同时也应该在异常和其他错误处理手段之间进行权衡比较.

常使用try- catch语句、try- catch-fianlly语句.

针对产品代码的限制并不适用于开发中的软件.你可以利用这一优势在开发中添加有助于更快地排查错误的代码.
 

# 第09章 伪代码编程过程        

伪代码编程过程有助于减少设计和编写文档所需的工作量,同时提高这两项工作的质量.

要点:
- 创建类和子程序通常都是一个迭代的过程.
- 在创建子程序的过程中获得的认识常常会反过来影响类的设计.
- 编写好的伪代码需要使用易懂的英语,
    - 要避免使用特定编程语言中才有的特性,
    - 同时要在意图的层面上为伪代码
    - (即描述该做什么,而不是要怎么去做).
- 伪代码编程过程是一个行之有效的做详细设计的工具,它同时让编码工作更容易.
- 伪代码会直接转化为注释,从而确保了注释的准确度和实用性.


# 第10章 使用变量的一般事项    


数据认知创建有效数据的第一步是了解所有创建数据的种类.

变量使用:
    - 关闭隐式声明.
        - 隐式声明:当使用未声明的变量时,会自动声明.
        - 可以减少变量的错误名称等.
    - 声明全部的变量.可以清晰明了,较少错误,便于维护
    - 遵循命名规则
    - 使用工具检查变量名:删除无用变量

变量初始化规则:
    - 常产生的问题
        - 从未对变量赋值
        - 变量值已经过期
        - 变量的部分被赋值,部分没有
        - 其他....
    - 避免初始化错误的建议
        - 声明变量的时候初始化
        - 在靠近变量第一次使用的位置初始化
        - 理想情况下,在靠近第一次使用变量的位置声明和定义该变量
        - 可能的情况下使用final或const
        - 特别注意计数器和累计器
        - 在类的构造函数里初始化该类的数据成员
        - 检查是否需要初始化
        - 一次性初始化具名常量:用可执行代码初始化变量
        - 使用编译器设置自动初始化所有变量
        - 利用编译器的警告信息
        - 检查输入参数的合法性
        - 使用内存访问检查工具来检查错误的指针
        - 在程序开始时初始化工作内存

作用域:
    - 定义:作用域 - 衡量变量知名度的方法.
    - 作用域的规则
        - 使变量引用局部化.避免变量的多次不同位置修改,导致变量不清晰.
        - 尽可能索顿啊变量存活时间 live time.即变量存在期间跨越的语句总数.
        - 测量变量的生存时间.变量跨越的语句行数
    - 减小作用域的一般原则
        - 循环开始初始化变量
        - 变量即将被使用时为其赋值.
        - 把相关语句放到一起
        - 将相关语句组提取成单独的子程序
        - 开始时采用最严格的可见性,然后根据需要扩展变量的作用域.

缩小作用域的说明:
    - 方便性:侧重写代码
    - 智能的可管理性:侧重读代码

数据类型和控制结构之间的关系:
    - 数据类型和控制结构之间以一种定义明确的方式相互结合
    - 三种类型
        - 序列型数据翻译为程序中的顺序语句
        - 选择性数据翻译为程序中的if和case语句
        - 迭代性数据翻译为程序中的for循环等结构

变量使用的建议
    - 每个变量只用于单一用途
    - 避免让代码具有隐含含义
    - 确保使用所有已声明的变量

# 第11章 变量名的力量          

章节说明:
- 主要说明变量如何命名
- 介绍了命名规则
- 介绍了命名前缀


## 变量取名的注意事项:
- 好的变量名是可读的、易记的、恰如其分的.
- 变量命名的最重要考虑事项:名字要完全、准确地描述出该变量所代表的事物.
- 变量名称长度在10-16或8-20,易于调试和使用.
- 较长的名字适用于很少用到的变量或者全局变量,较短的名字则是浓郁局部变量或循环变量、临时变量等
- 变量名中的计算值限定词,例如sum、total等放在变量名称后.
- 变量名中的对仗词:例如begin/end,first/last

### 为特定类型的数据命名:
    - 为循环下标命名:
        - 循环内使用可以约定俗成用 i j k.循环外使用,可以用 XXXIndex
    - 为状态变量命名:
        - 取一个
    - 为临时变量命名:
        - 临时变量的多次使用,可以命令规范些
    - 为布尔变量命名
        - 典型的布尔变量:done error found success
        - 变量的真假含义:Ture False
        - 使用肯定的布尔变量名:notdone
    - 为枚举类型命名
        - 使用枚举的时候,可以使用组前缀命名约定
    - 为常量命名
        - 根据常量所表示的含义,而不是该常量所具有的数值为该抽象事务命令.
        - 非正式命令规则:
        - 与语言无关的命名规则的指导原则
            - 区分变量名和子程序名字
            - 区分类和对象 大小写方式
            - 标识全局变量 g_xxx
            - 标识成员变量 m_xxx
            - 标识类型声明 t_xxx
            - 标识具名常量 c_xxx
            - 标识枚举类型的元素 统一前缀
            - 格式化命名提高可读性:驼峰命名
        - 与语言相关的命名规则
            - 不同语言命名规则不同,混合语言编程可以对其命名规则作出优化.
        - 命名规则
            - 变量名包含信息
                - 变量的内容
                - 数据的种类
                - 变量的作用域
    - 标准前缀命名 

        - 前缀组成:用户自定义类型UDT的缩写 + 语义前缀
        - 用户自定义类型UDT

            - UDT缩写可以标识被命名对象或变量的数据类型
            - 常用的UDT缩写

                - ch 字符
                - doc 文档
                - pa 段落
                - scr 屏幕区域
                - sel 选中范围
                - wn 窗体
        - 语义前缀

            - c 数量
            - first 第一个元素
            - g 全局变量
            - i 数组下标
            - last 最后一个元素
            - lim 处理上限
            - m 类变量
            - max 列表等最后一个元素
            - min 列表等第一个元素
            - p 指针
        - 标准前缀的优点

            - 精准的描述含义比较模糊的名字
            - 使得名字变的更加紧凑
            - 准确对数据类型作出判断
    - 缩写的一般指导原则

        - 指导原则:

            - 标准缩写
            - 非前置原因
            - 去掉虚词 and or the
            - 使用每个单词首字母
            - 统一截断单词后面部分
            - 保留单词第一个和最后
            - 使用名字中每一个重要单词
            - 去掉无用后缀
            - 保留音节中重要发音
            - 不改变变量含义
            - 知道变量名称长度到 8 - 20,或者所需要的限制字符数.
        - 可以建立缩写对照表 -- 来解释短名称的含义.
        - 缩写的含义目的在于清晰可见.

##    - 应该避免的变量名称

        - 避免误解放入名字或缩写
        - 避免使用具有相似含义的名称
        - 避免使用具有不同含义但却有相似名称的变量
        - 避免发音相近的名字
        - 避免名称中使用数字
        - 避免使用英语中常常拼错的单次
        - 不要仅靠大小写来区分变量名
        - 强制使用多种自然语言
        - 避免使用标准类型、变量和子程序的名称
        - 不要使用与变量含义完全无关的名称
        - 避免在名称中包含容易混淆的字符


> 变量命名规则可以参考著名的匈牙利命名法.比如:
> 全局变量              g_
> 常量             c_
> c++类成员变量    m_
> 静态变量              s_ 


好的变量名提高程序可读性的一项关键要素.

对特殊种类的变量,比如循环下标很状态变量,需要加以特殊的考虑.

名字要尽可能地具体.那些太模糊或者太通用以致于能够用于多种目的的名字都是很不好的.

命名规则应该能够区分局部数据、类数据和全局数据.
它们还应当可以区分类型名、具名常量、枚举类型名字和变量名.

无论做那种类型项目,你都应该采用某种变量命名规则.
你所采用的规则的种类取决于你程序的规模,以及项目成员的人数.

现在编程语言很少需要用到缩写.如果你真的要使用缩写,
请使用项目缩写词典或者标准前缀来帮助理解缩写.

代码阅读的次数远远多于编写的次数.

**确保你所取的名字侧重于阅读方便而不是编写方便**

小结



# 第12章 基本数据类型          

    - 数值概论
        - 避免使用神秘数值,未解释的数值
        - 预防除零错误
        - 使类型转换变的明显
        - 避免混合类型的比较
        - 注意编译器的警告
    - 整数

        - 检查整数除法
        - 检查整数溢出
        - 检查中间结果溢出
    - 浮点数:

        - 避免数量级相差巨大的数之间的加减运算
        - 避免等量判断
        - 处理舍入误差问题
    - 字符和字符串:

        - 避免使用神秘字符和神秘字符串
        - 避免off-by-one错误
        - 了解你的语言和开放环境是如何支持unicode的
        - 在程序生命周期中尽快决定国际化或本地化策略
        - 需要支持多种语言,请使用Unicode
        - 采用某种一致的字符串类型转换策略
    - 布尔变量

        - 用布尔变量对程序加以文档说明
        - 用布尔变量来检查复杂的判断
        - 如果需要的话,创建自己的布尔类型
    - 枚举类型

        - 用枚举类型提供可读性
        - 用枚举类型提高可靠性
        - 用枚举类型简化修改
        - 将枚举类型作为布尔变量的替换方案
        - 检查非法数值
        - 定义出枚举的的第一项和最后一项,以便用于循环边界
        - 把枚举类型的第一个元素留作非法值
        - 明确定义项目代码编写标准中第一个和最后一个元素的使用规则,并且在使用时保持一致
        - 警惕给枚举元素明确赋值而带来的失误
    - 具名变量:类似变量,一旦赋值以后就不能再修改

        - 将程序参数化的方法
        - 在数据声明中使用具名常量,提高可读性和可维护性
        - 避免使用文字量,即使是“安全”的
        - 具有适当作用域的变量或类来模拟具名常量
        - 统一地使用具名常量
    - 数组

        - 确认所有的数组下标都没有超出数组的边界
        - 考虑用容器来取代数据,或者将数组作为顺序话结构来处理
        - 检查数组的边界点
        - 如果数组是多维的,确认下标的使用顺序是正确的
        - 提防下标串话
    - 创建自己的类型:自定义类型

        - 易于修改
        - 避免过多的信息分发
        - 增加可靠性
        - 弥补语言的不足
    - 自定类型创建的指导原则

        - 给所创建的类型取功能导向的名称
        - 避免使用预定义类型
        - 不要重定义一个预定义的类型
        - 定义替代类型以便于移植
        - 考虑创建一个类而不是typedef

数值、整数、浮点数、字符和字符串、布尔变量、枚举类型、具名常量、数组、创建类型要点:使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则.如果你的语言支持,创建自定义类型会使得你的程序更容易修改,并更具有自描述性.当你用typedef或者其等价方式创建了一个简单类型的时候,考虑是否更应该创建一个新的类.


# 第13章 不常见的数据类型      

    - 结构体
        - 用结构体来明确数据关系
        - 用结构体来简化参数列表
        - 用结构体来减少维护
    - 指针
        - 指针包含部分:内存中的位置,如何解释位置中的内容
        - pass 待定
        - 内存分配中使用 sizeof()确定变量的大小
    - 全局数据
        - 存在优缺点,建议尽量不用使用
        - 采用访问器子程序来取代去全局数据
            - 访问器子程序是实现抽象数据类型和信息隐藏的一种核心方法.
                - 底层的封装使用
                - 常用函数的封装使用
            - 使用锁来建立控制全局变量的访问
        - 全局变量的命令的规范和统一性

结构体、指针、全局数据要点:
- 结构体可以使得程序更简单、更容易理解,以及更容易维护.
- 每当你打算使用结构体的时候,考虑采用类是不是会工作得更好.
- 指针很容易出错.
- 用访问器子程序或者类以及防御式编程实践来保护自己的代码.
- 避免用全局变量,如果你不得不使用全局变量,那么就通过访问器子程序来使用它.


# 第14章 组织直线型代码        

必须有明确顺序的语句:
    - 设法组织代码,使依赖关系变得明显
    - 使子程序能突显依赖关系
    - 利用子程序参数明确显示依赖关系
    - 用注释对不清晰的依赖关系进行说明
    - 用断言或错误处理代码来检查依赖关系

顺序无关的语句
    - 使得代码易于自上而下的阅读
    - 将相关语句组织在一起

小结:
    - 组织直线型代码易于阅读
    - 依赖关系明显.

顺序结构要点:
- 组织直线型代码的最主要原则是按照依赖关系进行排列.
- 可以用好的子程序名、参数列表、注释.
- 如果代码足够重要,内务管理变量来让依赖关系变得更明显.
- 如果代码之间没有顺序依赖关系,那就设法使相关的语句尽可能地接近. 


# 第15章 if-else语句           


if-then-else语句:将常触发的条件放在前面

if-else,switch-case-default

要点:
- 对于简单的if-else语句,请注意if子句和else子句的顺序.
- 为了捕捉错误,可以使用case语句中的default子句,或者使用if-then-else语句中的最后那个esle子句.






# 第16章 控制循环              

选择循环的种类:
    - 计数循环
    - 连续求值循环
    - 无限循环
    - 迭代器循环
    - 循环控制
        - 循环常出现的问题:
            - 忽略或错误的对循环执行初始化、
            - 忽略对累加变量或其他与循环有关的变量执行初始化
            - 不正确的嵌套
            - 不正确的循环终止
            - 忽略或者错误的增加了循环变量的值
            - 不正确的数组下标

while for要点:
循环很复杂.保持循环简单将有助于别人阅读你的代码.

保持循环简单的技巧:
- 避免使用怪异的循环、
- 减少嵌套层次、
- 让入口和出口一目了然、
- 把内务操作代码放在一处.

循环下标很容易被滥用.因此命名要准确,并且要把它们各自仅有用于一个用途.仔细地考虑循环,确认它在每一种情况下都运行正常,并且在所有可能的条件下都能退出.


# 第17章 不常见的控制结构      


要点:
- 多个return可以增强子程序的可读性和可维护性,同时可以避免产生很深的嵌套逻辑.
- 递归能够很优雅地解决一小部分问题.对它的使用要加倍小心.在使用递归的时候需要注意:
    - 确认递归能够停止、
    - 使用安全计数器防止出现无穷递归、
    - 留心栈空间、
    - 不要用递归去计算阶乘或者斐波那契数列.
- 除非万不得已最好不要使用goto,因为逻辑结构比较混乱.

# 第18章 表驱动法              

表驱动法是一种编程模式,从表里面查找信息而不是使用逻辑语句.事实上,凡是能通过逻辑语句来选择的事物,都可以通过查表来选择.对于简单的情况而言,使用逻辑语句更为容易和直白.但随着逻辑链的越来越复杂,查表法也是愈发显示地更具有吸引力.
要点:
表提供了一种复杂的逻辑和继承结构的替换的方案.如果你发现自己对某个应用程序的逻辑和继承树关系感到困惑,那么问问自己它是否可以通过一个查询表来加以简化.
使用表的一项关键决策是决定如何去访问表.你可以采取直接访问、索引访问、阶梯访问.阶梯访问是通过确定每项命中的阶梯层次确定其归类,它命中的“台阶”确定其类属.
使用表的另一项关键决策是决定应该把什么内容放入表中.

# 第19章 一般控制问题          

要点:
- 使用布尔表达式简单可读,将非常有助于提高你的代码的质量.
- 深层次的嵌套使得子程序变得难以理解.所幸的是,你可以相对容易地避免这么做.
- 结构化编程是一种简单并且仍然使用的思想,你可以通过顺序、选择、循环三者组合起来而开发出任何程序.
- 将复杂度降低到最低水平是编写高质量代码的关键.

# 第20章 软件质量              

软件同时拥有内在和外在的质量特性.外在特性指的是该产品的用户所能够感受到的部分,包括正确性、可用性、效率、可靠性、完整性、适应性、精确性、健壮性.内在特性包括可维护性、灵活性、可移植性、可重用性、可读性、可测试性、可理解性.


要点:
- 开发高质量代码最终并没有要求你付出更多,
    - 只是你需要对资源进行重新分配,
    - 以低廉的成本来放置缺陷出现,从而避免代价高昂的修正工作
- 并非所有的质量保证目标都可以全部实现.
    - 明确哪些目标是你希望达到的,并就这些目标和团队成员进行沟通.
- 没有任何一种错误检测方式能够解决全部问题,
    - 测试本身并不是排除错误的最有效方法,
    - 成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误
- 在构建期间应当使用一些有效的质量保证技术,
    - 但在这之前,一些具有同样强大功能的质量保证技术也是必不可少的.
    - 错误发现的越早,它与其他代码的纠缠就越少,有此造成的损失也越小.
- 软件领域的质量保证是面向过程的.
    - 软件开发与制造业不一样,在这里并不存在会影响最终产品的重复的阶段,
    - 因此,最终产品的质量受到开发软件所用的过程的控制

# 第21章 协同构建              

协同构建包括结对编程、正式检查、非正式技术复查、文档阅读,以及其他开发人员共同承担创建代码及其他工作产品责任的技术.



要点:



# 第22章 开发者测试            

## 开发者测试测试活动的几种类别
    * 单元测试
        * 完整的类或小程序等
        * <=单个开发团队
    * 组件测试
        * 类或包等
        * <=多个开发团队
    * 集成测试
        * 多个类,多个包或子系统等
        * <=多个开发团队,持续到整个系统开发完成
    * 回归测试
        * 重复执行以前的测试用例,用于验证缺陷已修正
    * 系统测试
        * 测试整个软件,测试安全、性能、资源消耗、时序方面问题.

测试分类
    * 黑盒测试
    * 白盒测试

## 测试的技巧锦囊

不完整的测试
    * 测试的窍门在于选择那些最优可能找到错误的测试用例.

结构化基础测试
    * 对于程序中每条语句、可能性进行测试.对于通过程序的所有可能路径进行测试

数据流测试
    * 检测不正常的数据流状态,正常状态为 已定义-一次/多次使用-可能已销毁

等价类划分
    * 对于揭示相同一个错误的多个用例,其他用例时无意义的,有助于减少所需用例的数量

猜测错误
    * 基于直觉或过去的经验,猜测程序会在哪里出错并在此基础上建立测试用例.

边界值分析
    * 单个边界值/复合边界值.用于测试数据的边界值

几类坏数据
    * 数据太少(无数据)
    * 太多数据
    * 错误数据(无效数据)
    * 长度错误的数据
    * 未初始化的数据

几类好数据
    * 正常情形
    * 最小的正常情形,最大的正常情形
    * 与旧数据的兼容性

22.4 典型错误绝大多数错误往往与少数几个具有严重缺陷的子程序有关.82定理:
    * 80%的错误存在于项目20%的类或者子程序中
    * 项目中20%的程序,占用了80%的成本
    * 修正20%的错误,需要消耗80%的资源

错误分类
    * 结构方面问题 25
    * 数据 22
    * 已实现的功能 16
    * 构建 10 
    * 集成 10
    * 功能需求 8
    * 测试的定义或者执行 2
    * 系统、软件架构 1.7
    * 未归类 4.7

错误的研究结果
    * 大多数错误
    * 

## 测试支持工具
    * 使用桩函数来测试类构造
    * DIFF工具,比对实际结果和预期结果
    * 测试数据生成器: 制造随机测试数据,进行测试
    * 覆盖率监视器:显示哪些代码在测试汇总还未执行
    * 日志记录器:收集错误信息、收集程序状态信息
    * 符号调试器:走查和详查代码的技术辅助工具.针对代码行进行调试,跟踪变量值.类似于 chrome的js调试器

        * 代码走查(code walkthrough)是一个开发人员与架构师集中讨论代码的过程
    * 系统干扰器:测试由于系统缘故导致偶尔的代码故障.使用系统干扰器对系统进行干扰,从而处理系统异常引起的错误.

        * 内存填充
        * 内存抖动
        * 选择性内存失败
        * 内存访问检查、边界检查等
    * 错误数据库

        * 存放以往错误的数据库.
        * 能检查重复出现的错误,即时获取已纠正错误和已发现错误的比例

## 改善测试过程

有计划的测试
    * 项目初时,规划测试计划

重新测试,回归测试
    * 避免新的修改引起原有代码新的错误

自动化测试
    * 减少手动测试的工作量,提高测试效率

## 保留测试记录

保留测试记录,能够记录常犯的错误及其测试、修正带所耗时间.

单元测试、组件测试、集成测试回归测试、自动化测试要点:
- 开发人员测试是完整测试策略的一个关键部分.
- 同编码之后编写测试用例相比较,编码开始之前编写测试用例,
    - 工作量和花费的时间差不多,但是后者可以缩短缺陷-侦测-调试-修正这一周期.
- 即使考虑到了各种可用的测试手段,测试仍然只是良好软件质量计划的一部分.
    - 你可以根据各种不同的思路产生很多测试用例,
    - 这些思路包括基础测试、数据流分析、边界分析、错误数据类型以及正确数据类型等.
    - 你还可以通过猜测错误的方式得到更多的测试用例.
    - 错误往往集中在少数几个容易出错的类和子程序上,找出这部分代码,重新设计和编写它们.


# 第23章 调试                  

调试是确定错误根本原因并纠正此错误的过程.测试是检测错误的过程.

在一些项目中,调试会占到整个开发周期的50%.

## 23.1 调试概述

代码中的错误多称为 "errors"(错误),"defects"(缺陷),faults(失误).

开发高质量软件产品的最佳途径是精确描述需求,完善设计,并使用高质量的代码编写规范.


### 23.1.1 调试效率的巨大差异

以下是12个缺陷,不同程序员调试的效率软件质量的普遍性原则:提高软件质量能够减少开发成本.最好的程序员能够找出最多的错误,最快的找出错误,并且往往能够正确改正错误.23.1.2 有所获的缺陷如果你希望程序里面一个缺陷(defect)也没有,那意味着你还没有完全理解程序的功能.你并不需要学会如何修正缺陷,你应该学会如何在一开始就避免缺陷的产生.
    - 理解你正在编写的程序
    - 明确你犯了哪种类型的错误
    - 审视自己解决问题的方法
    - 审视自己修正缺陷的方法

23.1.3 效率低下的调试方法调试之魔鬼指南
    - 凭猜测找出缺陷

        - 使用print方式,定位代码问题.
        - 使用修改代码方式,通过部分代码是否正常工作,来定位代码问题.
    - 不要把时间浪费在理解问题

        - 不需要理解产生问题的所有代码,只要找出问题就可以了
    - 用最简单的方法修正错误

        - 代码的修改方式,返回最初的函数/类修改,较麻烦.直接在异常问题的地方直接修改代码,较简单.

迷信式调试
    - 每个团队里也许都会有这样一个程序员,总会遇到无穷的问题.这些问题其实都是自己产生的,如果不是,也请联想到自己产生的.

## 寻找缺陷

调试包括了寻找缺陷和修正缺陷.寻找缺陷并理解缺陷,通常占到这个调试工作的90%.

高效的程序员是低效程序员花费的时间的1/20.

### 科学的调试方法

经典的科学调试方法步骤
    - 通过可重复试验收集数据
    - 根据相关数据统计构造一个假说
    - 设计一个试验来证明或反证这个假说
    - 证明或反证假说
    - 根据需要重复以上步骤

寻找缺陷的有效样例
    - 将错误状态稳定下来
    - 确定错误的来源
        - 收集产生缺陷的相关数据
        - 分析所收集的数据,并构造对缺陷的假设
        - 确定怎样去证实或证伪这个假设,可以对程序进行测试或检查代码
        - 重复上一个步骤,得出假设的结论
    - 修补缺陷
    - 对所修补的地方进行测试.
    - 查找是否还有类似的错误.

### 将错误稳定下来

如果错误无法稳定下来,几乎不可能找出错误发生的原因.

调试工作中,让不定期出现的错误有规律的重现是最具挑战的任务之一.

确定错误原因同样需要运用科学方法.

### 寻找缺陷的一些小建议

一旦将错误的发生稳定下来并精简了产生该错误的测试用例.
寻觅错误要么很复杂,要么很简单,这取决于代码质量.
如果寻觅错误遇到了麻烦,那么很可能是因为代码写的不好. 

**寻找缺陷的一些有效方法:**
    - 在构造假设时考虑所有的可用数据
    - 提炼产生错误的测试用例
    - 在自己的单元测试族中测试代码.
    - 利用可用的工具
    - 采用多种不同的方法来重现错误
    - 用更多的数据生成更多的假设
    - 利用否定性测试用例的结果
    - 对可能的假设尝试头脑风暴
    - 在桌上放一个记事本,把需要尝试的事情逐条列出
    - 缩小嫌疑代码的范围
    - 对之前出现过缺陷的类和子程序保持警惕
    - 检查最近修改过的代码
    - 扩展嫌疑代码的范围
    - 增量式集成
    - 检查常见缺陷
    - 同其他人讨论问题
    - 抛开问题,休息一下

蛮力调试:被认为是一种乏味、费神、耗时但是能确定可以最终解决问题的方法.

蛮力调试或许有效,但是需要一个时间限制来保证调试的效率,也需要一张蛮力调试方法列表,避免进行重复无效的调试.保证解决问题的特定技术需要结合具体情况来考虑


### 语法错误

语法错误问题在编辑器越来越好时,已经逐渐消失了.

常见解决语法错误的方法
    - 不要过分信任编译器信息中的行号.(因为错误不一定是这行引起的,例如缩进错误/缺失]}等)
    - 不要迷信编译器信息.(编译器信息不一定是完全正确的)
    - 不要轻信编译器的第二条信息.(多条错误信息时,第二条有可能是第一条引起的.不要着急,从第一条开始解决)
    - 分而治之.(将程序进行模块划分,修改代码查看错误情况,从而精准定位错误位置)
    - 找出没有配对的注释或者引号.(大多数情况下的语法错误,都是因为符号没有写全导致的.所以符号一开始就写全,能够避免这种错误发生)

## 23.3 修正缺陷

调试中最为麻烦的是寻找缺陷.修正缺陷则是较为简单的部分.

修正缺陷的一些建议
    - 在动手之前先要理解问题.(在修补问题之前,请保证你已经透彻的理解问题,知道你能正确的预测出运行结果为止.否则你的修改极大可能是有隐患的.)
    - 理解程序本身,而不仅仅是问题.(研究发现,对着整个程序由全局理解的比只关注局部程序的程序员成功修改程序可能性高得多.理解相关的代码 - 几百行)
    - 放松一下.匆忙动手解决问题是最低效的事情之一,这极易导致问题重复出现,或引起新的问题.不妨休息一下,或者干其他事情,之后再重新检验修改是否正确.
    - 保存最初的源代码.修改之前备份,修改之后比对修改的内容,做修改确认
    - 治本,而不是治标.没有彻底理解问题,就不要取修改代码,因为这会把代码搞得更糟糕.
    - 修改代码时一定要有恰当的理由.(不能因为好像有问题,好像低效,就去修改.也不要去随机修改代码,仅仅满足于让代码生效而已)
    - 一次只做一个改动.(精确目标,避免多元因素影响.问题简单化)
    - 检查自己的改动.(谁也无法保证自己一定是对的,但是你也可以保证尽最大的力气也找不出你的错误.)
    - 增加能暴露问题的单元测试.(如果测试工具集无法检测出这个错误,那么就增加一个测试用例来完善测试工具集)
    - 搜索类似的缺陷.(解决这个问题之后,思考有没有类似的,可以一起解决的)

## 23.4调试中的心理因素


心理取向,你会看到你所希望看到的东西.
你会看到你认为正确的东西,而忽视了眼前的错误.

心理距离:不同名称存在一个心理距离,心理距离越小,你越会认为错误的是正确的.越会认为和你希望的一样.

## 23.5 调试工具调试工具的种类/介绍.
    - 源代码比较工具:diff
    - 编译器的警告消息
        - 将编译器的警告级别设置为最高,不放过任何一个错误
        - 用对待错误的态度处理警告
        - 在项目范围内使用统一的编译设置
    - 增强的语法检查和逻辑检查
        - 例如 XXX 工具
    - 执行性能解析器
        - 通过异常的性能消耗,监测出代码问题,优化代码
    - 测试框架
        - 通过测试用例检测代码
    - 调试器
        - 例如 chrome 的断点调试器

**寻找缺陷的方法:**
- 使用所有可用数据来构造你的假设.
- 不断提炼产生错误的测试用例.
- 在自己的单元测试族中测试代码.
- 借助可以获得的任何工具.
- 用不同的方式重现错误.
- 通过产生更多的数据来构造更多的假设.
- 用头脑风暴的方式找出可能的假设.
- 在桌上放一个笔记本,把需要尝试的事情列出来.
- 缩小被怀疑有问题的代码区域.
- 对之前出现过问题的类和子程序保存警惕.
- 检查最近修改的代码.
- 扩展被怀疑有问题的代码区域.
- 采用增量集成.
- 检查常见的缺陷.
- 和其他人一起讨论你的问题.
- 抛开问题休息一下.
- 列出所有的蛮力调试方法,逐条应用.

**解决语法错误的方法:**
- 不要太信任编译器信息中给出的行号.
- 不要太信任编译器信息.
- 分而治之,各个击破.
- 使用具有语法分析功能的编译器来找出位置错误的注释和行号.

**修正缺陷的方法:**
- 在动手之前先理解程序.
- 验证对错误的分析.
- 放松一下.
- 要保存最初的源代码.
- 只有当理由充分的时候才去修改代码.
- 一次只做一个改动.
- 添加单元测试来暴露代码中缺陷.

# **要点:**
- 在动手解决问题之前,要理解问题的根本.
- 将编译器警告级别设置为最严格,把警告信息说报告的错误都改正.
- 调试工具对软件开发而言是强有力的支持手段.

# 第24章 重构(函数抽象、封装)            

神话一样的软件项目,应该首先以系统化的方法进行需求开发,定义一份严谨的列表来描述程序的功能.涉及完全遵循需求,并且编写的相当仔细,绝大多数编程首次编写就已经完美.当然这只是传说,不合现实.


## 24.1 软件演化的类型区分

软件演化类型的关键:
- 程序的质量值提高还是降低了.
- 软件演化是源于程序构建过程中的修改,还是维护过程中的修改.

构建中的修改代价小.

软件演化,可以重新审视自己的代码,并竭尽所学去改进,会更有益于你的开发.

软件演化是无法避免且有重要意义的现象.

## 24.2 重构简介

重构的定义:尽可能的将一个程序分解为多个组成部分.

### 24.2.1 重构的理由

当代码在维护过程中质量降低,或者代码原本就存在问题,一般而言,都需要重构.


重构常见的几种理由:
- 代码重复
- 冗长的子程序

**在面对对象的编程中,很少会用到长度超过一个屏幕大的子程序,这种情况意味着其中部分代码需要重构抽离出来.**

需要重构的程序:
- 循环过程或嵌套过深
- 内聚性太差的类
- 类的接口未能提供层次一致的抽象
- 拥有太多参数的参数列表(说明接口抽象时未经过详细的斟酌)
- 类的内部修改往往被局限于某个部分(某处修改会同时影响多个部分,说明可以被抽离)
- 变化导致对多个类的相同修改.(比如增加一种输入方式,导致多处需要修改以支持此输入)
- 对继承体系的相同修改
- case语句需要做相同的修改(类似于代码重复,未准确完善的归类可能性)
- 同时使用的相关数据未以类的方式进行组织(多次重复使用的数据,可以归于类中)
- 成员函数使用其他类的特征比使用自身类的特征还要多.(说明应该放在另外一个类中)
- 过多使用基本数据类型
- 某个类无所事事
- 一系列传递流浪数据的子程序(数据传输来和去,仅仅为了数据传输)
- 中间人对象无事可做
- 某个类同其他类关系过于亲密
- 子程序命名不恰当
- 数据成员被设置为公用
- 某个派生类仅仅使用了基类的很少一部分成员函数
- 注释被用于解释难懂的代码(不要为拙劣的代码编写注释,应当重写代码)
- 使用了全局变量
- 在子程序调用前使用了设置代码,或在调用后使用了收尾代码.
- 程序中的一些代码似乎在将来才可能用到.(超前代码意味着需求不是很明确,意味着代码重写的概率极高,类似于白写)

重构不是简单对代码修改的定义,而是采用正确的方法修复、完善代码.

## 24.3 特定的重构

### 数据级的重构

数据级的重构 - 改善变量和其他数据类型的使用
- 用具体常量替代神秘数值
- 使变量的名字更为清晰且传递更多信息
- 使表达式内联化.  # 减少无用的变量,将一个中间变量换成给他赋值的那个表达式本身.
- 用函数来代替表达式
- 引入中间变量  # 中间变量的命名一定要准确描述其内容
- 用多个单一用途变量代替某个多用途变量.
- 在局部用途中使用局部变量而不是参数
- 将基础数据类型转换为类
- 将一组类型码转换为类或枚举类型
- 将一组类型码转换为一个基类机器相应派生类
- 将数组转换为对象
- 把群集封装起来
- 用数据类来代替传统记录

### 语句级的重构

语句级的重构 - 改善单个语句的使用
- 分解布尔表达式
- 将复杂布尔表达式转换成命名准确的布尔
- 合并条件语句不同部分中重复代码片段
- 使用break或return而不是循环控制变量
- 在嵌套的if-then-else语句中一旦知道答案就立即返回,而不是去附一个返回值.(这种代码便于分析)
- 用多态替代条件语句(尤其是重复的case语句)、(case逻辑放在继承关系中,通过多态函数调用实现)
- 创建和使用null对象而不是去监测空值.

### 程序序级重构

程序序级重构 - 改善单个子程序一级的代码
- 提取子程序或者方法.(将内嵌代码提取出来)
- 将子程序代码内联化
- 将冗长得到子程序转换为类
- 用简单算法替代复杂算法
- 增加参数
- 删除参数
- 将查询操作从修改操作中独立出来
- 合并相似的子程序,通过参数区分它们的功能.
- 将行为取决于参数的子程序拆分开来
- 传递整个对象而非特定成员.(当对象中多个值被传递,可以直接传递对象)
- 传递特定成员而非整个对象(对对象中只有少数被传递使用,修改使其接收特定数据成员)
- 包装向下转型的操作.

### 类实现的重构
类实现的重构 - 改善类一级别的代码
    * 

## 24.4 安全的重构

重构是一种改善代码质量的强有力技术.

重构的一些建议
- 保存初始代码.代码备份,便于比对代码修改和代码还原
- 重构的步伐请小些.能够详细理解所做修改对程序的全部影响.
- 同一时间只做一项重构.避免多元素影响,简单化
- 把要做的事情一条条列出来.一份重构列表可以保证思维连贯.
- 设置一个停车场.重构的过程中,发现可以进行新的重构.可以将这些重构工作列出来,用于未来处理
- 多使用检查点
- 利用编译器警告信息
- 重新测试.检查代码修改的是否正确
- 增加测试用例,某些情况需要增加测试用例以检验修改
- 检查代码的修改.
    - 程序员对于单行代码的修改,错误率在50%左右,随着代码行数的增加,代码错误率不断降低.
    - 简单的修改也要当成复杂修改加以对待.
    - 根据重构风险级别来调整重构方法.不同重构内容对其他影响也不尽相同.对于有风险的重构,需要详细检查代码和测试.

## 24.5 不宜重构的情况

重构的含义是在不影响程序行为的前提下改进可运行的代码.

- 不要把重构当成先写后改的代名词
- 避免用重构代替重写

## 24.5 重构策略

重构也符合收益递减定量和80/20法则.

数据级别重构:
用具名常量来代替神秘数值.
用更明确或更具信息量的名字来重命名变量.
将表达式内联化.
用函数来代替表达式.
引入中间变量.
将多用途变量转换为多个单一用途变量.
将一组类型码转化为类或枚举类型或含派生类的类.
将数组转化为对象.
封装群集.
用数据类替代传统记录.

语句级的重构:
- 分解布尔表达式.
- 将复杂的布尔表达式转换为命名精确的布尔函数.
- 将条件语句中不同部分中的重复代码合并.

子程序级的重构:
- 提取子程序.
- 将子程序代码内联化.
- 将冗长的子程序转化为类.
- 用简单的算法替代复杂算法.

类实现的重构:
- 将值对象改为引用对象.
- 用数据初始化来替代虚函数.
- 改变成员函数或者数据的位置.
- 将特定的代码提出生产派生类.
- 将相似的代码合并起来放到基类中.

类接口的重构:
- 将一个类转化成两个.
- 引入外部子程序.
- 引入扩展类.
- 封装暴露在外的成员变量.

系统级的重构:
- 使用工厂函数而非简单的构造函数.

# 要点

重构成功的另一要素是程序员应当掌握大量特定的重构方法.

重构成功的最后要点在于要有安全重构的策略.


# 第25章 代码调整策略          


代码调整方法:
- 用设计良好的代码来开发软件,从而使程序易于理解和修改.
- 如果程序性能很差.
    - 保存代码的可运行版本,这样你才能回到“最近的已知正常状态”；
    - 对系统进行分析测量,找出热点；
    - 判断性能差劣是否源于设计、数据类型或算法上的缺陷,确定是否应该做代码调整,如果不是,请跳回第一步；
    - 对步骤c中所确定的瓶颈代码进行调整；
    - 每次调整后都要对性能提升进行测量；
    - 如果调整没有改进代码的性能,就恢复到步骤a保存的代码.
- 重复步骤2.

要点:
- 性能只是软件整体质量的一个方面,通常不是最重要的.
- 绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间.如果没有测量,你不会知道是哪一部分代码.

# 第26章 代码调整技术          


要点:
- 优化结果在不同的语言、编译器和环境下有很大的差异.如果没有对每一次的优化进行测量,你将无法判断优化到底是帮助还是损害了这个程序.
- 第一次优化通常不会是最好的.即使找到了效果很不错的,也不要停下扩大战果的步伐.
- 代码调整可能会损害代码可读性和可维护性,也可能会有害. 调整需要谨慎行事.




# 第27章 程序规模对构建的影响  

要点:
- 随着项目规模的扩大,交流需要加以支持.
- 在其他条件等同时,大项目的生产率会低于小项目.
- 放大轻量级的方法论要好于缩小重量级的方法论.最有效的办法是使用“适量级”方法论.



# 第28章 管理构建              

配置管理、备份计划

要点:
- 好的软件评估是一项重大挑战.成功的关键包括采用多种方法、随着项目的开展而修缮评估结果.
- 度量是构建管理成功的关键.准确的度量是制定准确的进度表、质量控制和改进开发过程的关键.
- 程序员和管理人员都是人,在把他们当人看的时候工作得最好.

# 第29章 集成                  

> 集成是一种软件开发行为:将一些独立的软件组件组合为一个完整系统.

集成频率——阶段式集成与增量集成增量式集成:


增量式集成
- 自顶向下:它从主控模块开始,按照软件的控制层次结构,以深度优先或广度优先的策略,逐步把各个模块集成在一起.(桩模块不好写出来)
- 自底向上:自底向上测试是从原子模块(即软件结构最低层的模块)开始组装测试,因测试到较高层模块时,所需的下层模块功能均已具备,所以不再需要桩模块. (不用桩模块,驱动程序好写)
- 自顶向下:广度优先、深度优先

非增量式集成:
- 这种方法容易出现混乱.因为测试时可能发现一大堆错误,为每个错误定位和纠正非常困难,并且在改正一个错误的同时又可能引入新的错误,新旧错误混杂,更难断定出错的原因和位置. 常见但不好

要点:
- 构建的先后次序和集成的步骤会影响涉及、编码、测试各类的顺序
- 一个经过充分思考的集成顺序可以减少测试的工作量,并使得调试变的容易
- 增量集成,通常都会比阶段式集成好.
- 针对每个特定的项目,
    - 最佳的集成步骤通常是自顶向下、自底向上、风险导向及其他集成方法的某种组合.
    - T型集成和竖直分块集成通常都能工作得很好.




# 第30章 编程工具              

常见的编程工具:
- 设计工具(Rose、visio)
- 源代码工具(IDE集成工具、diff比较工具、版本控制工具、生产接口文档工具)
- 可执行工具(编译器与连接器、Build工具、程序库、代码生成工具、安装程序的工具)

测试,下列功能特性和工具有助于你进行有效的测试:
- 自动测试框架,如JUnit、NUnit、CppUnit等
- 测试用例的记录和回放工具
- 覆盖率监视器
- 系统扰动器(内存填充工具、内存“抖动”工具、内存访问检查器)
- Diff工具(比较数据稳健、图像等)
- 缺陷注入工具
- 缺陷跟踪工具


要点:
- 好的工具能让你的日子过得安逸很多.
- 下面这些工具可用:
    - 编辑
    - 分析代码质量
    - 重构
    - 版本控制
    - 除错
    - 测试
    - 代码调整

# 第31章 布局与风格            

计算机编程美学话题——程序源代码的布局.布局好的代码看起来不仅感觉漂亮而且结构也清晰.

## 布局技巧
用空格可以提高可读性.空格包括空格、制表符、断开行及空行.

用空格得到罗好的布局:
- 分组—— 一个代码段只能包含有关的、为完成某一任务而组织在一起的语句.
- 空格——在程序段的开头应当加空格表明
- 对方——把同属性的元素对齐.例如同一类语句的排成一条直线下来
- 缩排——当一个句子在逻辑上从属于上一个句子时,这个名子就比上一行退几格

要尽量的多用括号,有的时候表达式可能不需要使用括号,但加上括号会使表达的更清晰.

## 布局风格

### 控制结构布局

控制语句下的一组语句要区分成一组,再括起来.纯块结构、行尾布局这些名词化了,其实都见过的,“行尾布局”没用过,感觉这个最不好.文中给出的缺点是:无连续性而且难修改.

控制结构布局建议
- 段落之间使用空行
- 单语句代码块的格式前后统一
- 对于复杂的表达式,将条件分割放在几行上

### 单条语句布局
单条语句常规限制不超过80个字符,原因:超过了很难读、80个字符也防止了深层嵌套、80字符内方便打印.

单条语句布局建议:
- 逻辑表达式使用空格可增强可读性
- 用空格使数组下标更好读
- 用空格使子程序参数更好读

使续行明显 放在第一行那部分要清楚的表明它是语句的一部分.最好方法是第一行部分独立出来则有明显的语法错误

- 把紧密关联的元素放在一起
- 子程序调用的续行可后退标准格数
- 使续行的结尾易于发现
- 每行仅写一条语句

### 数据类型定义布局

数据类型定义布局建议
- 注意数据类型定义的对齐
- 每行定义一个数据
- 有意识地安排定义顺序

### 注释布局

一个好的注释能极大提高程序的可读性,若注释不成功,则会帮倒忙.
- 注释行与相应的代码行同样缩排
- 把注释行至少用一个空行分开

### 子程序布局

如何将子程序布局好,以下几点作为参考:
- 用空行把子程序各部分分开
- 对子程序的参数用标准缩排

### 文件、模块和程序布局

文件、模块和程序布局建议:
- 把一板块放在一个文件里
- 把一个文件内的子程序区分清楚
- 如果文件里有多个模块,要把这些模块区分得清清楚楚
- 各子程序按照字母顺序排列
- 在C中,细心地组织源文件

# 要点:

可视化布局的首要任务是指明代码的逻辑组织.
评估该任务是否实现的指标包括准确性、一致性、易读性和易维护性.
布局的很多方面涉及信仰问题.

# 第32章 自说明代码            

好的注释技巧一般问题:
    * 别人阅读你的代码能够立刻明白其意思吗
    * 你的注释是在解释代码用意,或概括代码功能,而非简单重复代码吗？
    * 采用了伪代码编程法来减少注释时间吗？
    * 是重写有玄机的代码,而非为其做注释吗？
    * 你的注释是和代码一起更新吗？
    * 注释清楚正确吗？
    * 你的注释风格便于修改注释吗？

语句和段落:
    * 代码避免用行尾注释了吗
    * 注释是主要说明为什么,而非怎么样吗
    * 注释为将要阅读代码的人们做好准备了吗
    * 每个注释都有其用处吗？删掉抑或改进了多余的、无关紧要的或随意的注释没有？
    * 是否注释了代码的非常规之处？
    * 避免使用缩略语了吗？
    * 主次注释区别明显吗？
    * 含错代码和未公开的代码特性有注释吗？

数据声明:
    * 对数据声明的注释说明了数值单位吗？
    * 数值数据的取值范围注释出来了吗？
    * 注释出了编码含义？
    * 对输入数据的限制有注释吗？
    * 对位标志做注释了吗？
    * 对各全局变量声明的地方对齐做注释了吗？
    * 各全局变量是通过命名规范、注释等来标识其意义吗
    * 神秘数值是否已具名常量或变量代替,而非只是标注之.

控制结构
    * 控制语句都注释了吗?
    * 冗长或者复杂的控制结构结尾处有注释吗?抑或可能的话,简化之从而省去注释了吗?

子程序
    * 各子程序的意图都注释出了吗?
    * 子程序的其他有关情况(诸如输入输出数据、接口假设、局限性、纠错、全局效果和算法来源)都注释出来了吗

文件、类和程序
    * 程序有简短的文档(就像在“以书本为范例”中说明的那样)给出程序组织的概述吗?
    * 每个文件的用途都有说明吗?
    * 作者姓名、email及电话号码在代码清单中都有吗




# 第33章 个人性格              

**好的个人性格优点**
聪明和谦虚、求知欲、诚实、交流与合作、创造力和纪律、懒惰、坚持、经验、习惯.


一些培养求知欲和把学习当做第一要务的特定方法:
- 在开发过程中建立自我意识、
- 对编程和开发过程做试验、
- 阅读解决问题的有关方法、
- 在行动之前做分析和计划、
- 学习成功项目的开发经验、
- 阅读文档、
- 阅读其他书本期刊、
- 同专业人士交往.

最有关系的性格为:
- 谦虚、
- 求知欲、
- 诚实、
- 创造力和纪律、
- 高明的偷懒.

很多程序员不愿意主动吸收新知识和技术,只依靠工作时偶尔接触新的信息.
如果你能抽出少量时间阅读和学习编程知识,要不了多久就能鹤立鸡群.

好性格与培养正确的习惯关系很大.要成为杰出的程序员,先要养成良好的习惯,其他自然水到渠成.

> 什么思想决定什么样行为;
> 什么样行为决定什么样的习惯,
> 什么样的习惯决定什么样性格,
> 而什么性格决定什么样的命运.
 

# **要点**
- 人的个性对其编程能力有直接影响.
- 最有关系的性格为:谦虚、求知欲、诚实、创造性和纪律,以及高明的偷懒.
- 程序员高手的性格与天分无关,而任何事都与个人发展相关.
- 出乎意料的是,小聪明、经验、坚持和疯狂既有助也有害.
- 很多程序员不愿主动吸收新知识和技术,只依靠工作时偶尔接触新的信息.
    - 如果你能抽出少量时间阅读和学习编程知识,要不了多久就能鹤立鸡群.
    - 好性格与培养正确的习惯关系甚大.
    - 要成为杰出的程序员,先要养成良好习惯,其他自然水到渠成.




# 第34章 软件工艺的话题        


合作开发要求团队成员之间进行广泛沟通,其次同计算机交互；
单人开发是自我交流,其次才是与计算机.

编程应基于问题域而非解决方案,这样便于复杂度管理.
开发时迭代次数越多,产品的质量越好.
墨守成规的方法有悖于高质量的软件开发.

**请将编程工具箱中填满各种编程工具,不断提高自己挑选合适工具的能力.**

# 要点
- 编程的主要目的之一是管理复杂性.
- 编程过程对最终产品有深远影响.
- 合作开发要求团队成员之间进行广泛沟通,甚于同计算机的交互;而单人开发则是自我交流,其次才是与计算机.
- 编程规范一旦滥用,只会雪上加霜;使用得当则能为开发环境带来良好机制,有助于管理复杂性和相互沟通
- 编程应基于问题域而非解决方案,这样便于复杂性管理.
- 注意警告信息,将其作为编程的疑点,因为编程几乎是纯粹的智力活动开发时迭代次数越多,产品的质量越好.
- 墨守成规的方法有悖于高质量的软件开发.请将编程工具箱中填满各种编程工具,不断提高自己挑选合适工具的能力.




# 第35章 何处有更多信息        

软件开发资料库由几类信息构成:
- 一类核心数据解释有效编程的基础概念；
- 相关的数据解释编程技术管理及知识背景；
- 还有关于编程语言、操作系统、环境和硬件等面向特定主题的参考书等.

期刊
- 初阶程序员技术杂志
- 高阶程序员学术期刊
- 专题出版物

软件开发者的阅读计划

**入门级必读书籍**

在 Construx,要迈过“入门级”,开发人员必须看以下书籍
        * 
Adams, James L. Conceptual Blockbusting: A Guide to Better Ideas), 4th ed
        * 
Cambridge, MA: Perseus Publishing, 2001 Bentley, Jon. <Pmgramming Pearls), 2d ed. Reading, MA: Addison-Wesley, 2000
    * 
Glass, Robert L. Facts and Fallacies of Software Engineering Boston, MA
    * 
Addison-Wesley, 2003
    * 
McConnell, Steve. (Software Project Survival Guide). Redmond, WA: Microsoft Press, 1998

        * 
McConnell, Steve. (Code Complete ) 2d ed Redmond, WA: Microsoft Press, 2004
    * 
熟练级必读书籍

        * 
要达到“中级”水平,程序员需要阅读以下材料.
        * 
Berczuk, Stephen P. and Brad Appleton. Software Configuration Management
        * 
PatternS: Efective Teamwork, Practical integration).Boston, MA: Addison-Wesley, 2003
        * 
Fowler, Martin. (UML Distilled: A Brief Guide to the Standard Object Modeling Language), 3d ed. Boston, MA: Addison-Wesley, 2003.
    * 
Glass, Robert L. Software Creativity). Reading, MA: Addison-Wesley, 1995
    * 
Kaner, Cem, Jack Falk, Hung Q Nguyen. (Testing Computer Software),2d ed. New York, NY: John wiley Sons, 1999
    * 
Larman, Craig. (Applying UML and Patterms: An Introduction to Object-Oriented
    * 
Analysis and Design and the Unified Process), 2d ed. Englewood Cliffs, NJ: Prentice Hall,
    * 
McConnell, Steve. (Rapid Development ). Redmond, WA: Microsoft Press, 1996 Wiegers, Karl. Software Requirements), 2d ed. Redmond, WA: Microsoft Press,2003,cc2e.com/k514
    * 
Manager's Handbook for Software Development, "NASA Goddard Space Flight enter Downloadable from sel gsfc. nasa. gov/website/documents/online-doc. htm
    * 
专业级必读书籍

        * 
在 Construx,软件开发者要读了下列资料才能达到专业级水平(领导阶层).
        * 
除了对开发者有一般性要求外,对各人还有特定要求.本节说明一般要求.
        * 
Bass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice)
        * 
2d ed. Boston, MA: Addison-Wesley, 2003
        * 
Fowler, Martin. Refactoring: Improving the Design of Existing Code). Readir
        * 
MA: Addison-Wesley, 1999
        * 
Gamma, Erich, et al. (Design Pattern.). Reading, MA: Addison-Wesley, 1995 州(第2版)
    * 
Gilb, Tom. Principles of Software Engineering Management). Wokingham,
    * 
England: Addison-Wesley, 1988
    * 
Maguire, Steve. (Writing Solid Code .Redmond, WA: Microsoft Press, 1993
    * 
Meyer, Bertrand. ( Object-Oriented Software Construction ) 2d ed. New York,
    * 
NY: Prentice Hall PTR, 1997 cc20.com/k521
    * 
fron. <Software Measurement Guidebook, "NASA Goddard Space Flight Center. Available cc2ecom3528要了解此专业发展计划及阅读清单的最新更新情况,请访问我们的专业开发
    * 
网站ww. construx.Com/ professionale/.



参加专业组织:
    * 
了解编程的最好途径是和其他程序员交往




# 第一部分 打好基础

# 第二部分 创建高质量的代码

# 第三部分 变量

# 第四部分 语句

# 第五部分 代码改善

# 第六部分 系统考虑

# 第七部分 软件工艺

# test

知行合一,止于至善

# Summary

* [书籍简介](readme.md)
* [第一部分 打好基础](p1打好基础.md)
    * [第00章 前言                  ](c00前言.md)
    * [第01章 欢迎进入软件架构      ](c01欢迎进入软件架构.md)
    * [第02章 用隐喻来理解软件开发  ](c02用隐喻来理解软件开发.md)
    * [第03章 前期准备              ](c03前期准备.md)
    * [第04章 关键点的构建决策      ](c04关键点的构建决策.md)
* [第二部分 创建高质量的代码](p2创建高质量的代码.md)
    * [第05章 软件构建中的设计      ](c05软件构建中的设计.md)
    * [第06章 可以工作的类          ](c06可以工作的类.md)
    * [第07章 高质量的子程序        ](c07高质量的子程序.md)
    * [第08章 防御式编程            ](c08防御式编程.md)
    * [第09章 伪代码编程过程        ](c09伪代码编程过程.md)
* [第三部分 变量](p3变量.md)
    * [第10章 使用变量的一般事项    ](c10使用变量的一般事项.md)
    * [第11章 变量名的力量          ](c11变量名的力量.md)
    * [第12章 基本数据类型          ](c12基本数据类型.md)
    * [第13章 不常见的数据类型      ](c13不常见的数据类型.md)
* [第四部分 语句](p4语句.md)
    * [第14章 组织直线型代码        ](c14组织直线型代码.md)
    * [第15章 if-else语句           ](c15if-else语句.md)
    * [第16章 控制循环              ](c16控制循环.md)
    * [第17章 不常见的控制结构      ](c17不常见的控制结构.md)
    * [第18章 表驱动法              ](c18表驱动法.md)
    * [第19章 一般控制问题          ](c19一般控制问题.md)
* [第五部分 代码改善](p5代码改善.md)
    * [第20章 软件质量              ](c20软件质量.md)
    * [第21章 协同构建              ](c21协同构建.md)
    * [第22章 开发者测试            ](c22开发者测试.md)
    * [第23章 调试                  ](c23调试.md)
    * [第24章 重构                  ](c24重构.md)
    * [第25章 代码调整策略          ](c25代码调整策略.md)
    * [第26章 代码调整技术          ](c26代码调整技术.md)
* [第六部分 系统考虑](p6系统考虑.md)
    * [第27章 程序规模对构建的影响  ](c27程序规模对构建的影响.md)
    * [第28章 管理构建              ](c28管理构建.md)
    * [第29章 集成                  ](c29集成.md)
    * [第30章 编程工具              ](c30编程工具.md)
* [第七部分 软件工艺](p7软件工艺.md)
    * [第31章 布局与风格            ](c31布局与风格.md)
    * [第32章 自说明代码            ](c32自说明代码.md)
    * [第33章 个人性格              ](c33个人性格.md)
    * [第34章 软件工艺的话题        ](c34软件工艺的话题.md)
    * [第35章 何处有更多信息        ](c35何处有更多信息.md)

